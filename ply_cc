#!/usr/bin/env python

import os
import re
import sys

#import ply.lex as lex
#import ply.yacc as yacc

states = [
	('statement', 'exclusive'),
    ('statementcommand', 'exclusive'),
    ('cppcommand', 'exclusive'),
	('block', 'exclusive')
	#('HTML', 'exclusive')
]

tokens = [
    'NL',
    'COMMAND',
    'BEGIN_STATEMENT','END_STATEMENT',
    'NUMBER','IDENTIFIER','STRING','CHAR','ZERO',
    'SCOPE', 'MEMBER', 'PTRMEMBER', 'LPAREN', 'RPAREN', 'COMMA', 'INC', 'DEC', 'STAR',
    'HTML'
    ]

reserved = {
        '=' : 'EQ',
        'skin' : 'SKIN',
        'view' : 'VIEW',
        'uses' : 'USES',
        'template' : 'TMPL',
        'extends' : 'EXTENDS',
        'url' : 'URL',
        'using' : 'USING',
        'if' : 'IF',
        'not' : 'NOT',
        'else' : 'ELSE',
        'foreach' : 'FOREACH',
        'in' : 'IN',
        'item' : 'ITEM',
        'end' : 'END',
        'c++' : 'CPP',
        }

tokens += reserved.values()

t_ignore = " \t"
t_statementcommand_ignore = " \t"
t_statement_ignore = " \t"
t_block_ignore = ""
t_cppcommand_ignore = ""

def t_begin_statement(t):
    r'<%'
    t.lexer.push_state('statement')
    t.lexer.push_state('statementcommand')
    t.type = 'BEGIN_STATEMENT'
    return t

def t_statementcommand_COMMAND(t):
    r'[^ \t\n]+'

    if t.value not in reserved:
        raise Exception(t.value + " is not a valid command")

    t.type = reserved[t.value]
    t.lexer.pop_state()
    t.lexer.command = t.type
    if t.type == 'CPP':
        t.lexer.pop_state()
        t.lexer.push_state('cppcommand')
    return t

t_cppcommand_COMMAND = r'.+(?=%>)'

def t_statement_end(t):
    r'%>'
    t.lexer.pop_state()
    if t.lexer.command in [ 'TMPL', 'IF', 'FOREACH', 'ITEM' ]:
        t.lexer.push_state('block')
    elif t.lexer.command == 'END':
        if t.lexer.lexstate == 'block':
            t.lexer.pop_state()
    t.type = 'END_STATEMENT'
    return t

t_cppcommand_end = t_statement_end


t_statement_INC = r'\+\+'
t_statement_SCOPE = r'::'
t_statement_MEMBER = r'\.'
t_statement_PTRMEMBER = r'->'
t_statement_LPAREN = r'\('
t_statement_RPAREN = r'\)'
t_statement_COMMA = r','
t_statement_STRING = r'"([^"]|\\")*"'
t_statement_CHAR = r'\'.\''
t_statement_STAR = r'\*'

t_block_HTML = r'([^<]|<(?!%))+'

t_block_begin_statement = t_begin_statement

def t_statement_IDENTIFIER(t):
    r'[a-zA-Z]\w*'
    t.type = reserved.get(t.value, 'IDENTIFIER')
    return t


def t_error(t):
    print('error: ' + str(t))
    return t

t_statement_error = t_error
t_statementcommand_error = t_error
t_cppcommand_error = t_error
t_block_error = t_error

def t_NL(t):
    r'\n+'
    t.lexer.lineno += len(t.value)

t_statement_NL = t_NL
t_statementcommand_NL = t_NL
t_cppcommand_NL = t_NL

def t_block_NL(t):
    r'\n'
    t.lexer.lineno += 1
    return t

start = 'translation_unit'

def non_empty_sequence(p):
    if type(p[1]) == list:
        p[0] = p[1] + [ p[2] ]
    else:
        p[0] = [ p[1] ]

def sequence(p):
    if len(p) == 3:
        p[0] = p[1] + [ p[2] ]
    elif len(p) == 2:
        p[0] = [ p[1] ]
    else:
        p[0] = []

p_translation_unit = lambda p: non_empty_sequence(p)
p_translation_unit.__doc__ =  '''translation_unit : translation_unit decl
                                                  | decl'''

def p_decl(p):
    '''decl : cpp_decl
            | skin_decl'''
    p[0] = p[1]

def register(clz, mod):
    name = 'p_' + clz.__doc__.split(' ')[0]
    mod[name] = lambda p: clz(p)
    mod[name].__doc__ = clz.__doc__
    reg = getattr(clz, 'register', None)
    if reg:
        reg(mod) # call class-supplied register(module) method

class CppDecl:
    'cpp_decl : BEGIN_STATEMENT CPP COMMAND END_STATEMENT'
    def __init__(self, p):
        p[0] = self
        self.cpp_command = p[3]
        self.lineno = p.lineno(3)
    def __repr__(self):
        return 'CppDecl(' + self.cpp_command + ')@' + str(self.lineno)

register(CppDecl, vars())

class SkinDecl:
    'skin_decl : begin_skin_block view_seq end_block'
    def __init__(self, p):
        p[0] = self
        self.begin = p[1]
        self.seq = p[2]
        self.end = p[3]
    def __repr__(self):
        return 'SkinDecl(' + repr(self.begin) + ';' + repr(self.seq) + ';' + repr(self.end) + ')'
    def register(module):
        module['p_view_seq'] = lambda p: non_empty_sequence(p)
        module['p_view_seq'].__doc__ = '''view_seq : view_seq view_decl
                                                   | view_decl'''
register(SkinDecl, vars())

class BeginSkinBlock:
    'begin_skin_block : BEGIN_STATEMENT SKIN IDENTIFIER END_STATEMENT'
    def __init__(self, p):
        p[0] = self
        self.name = p[3]
        self.lineno = p.lineno(1)
    def __repr__(self):
        return 'BeginSkinBlock("' + self.name + '")@' + str(self.lineno)

register(BeginSkinBlock, vars())

class EndBlock:
    'end_block : BEGIN_STATEMENT END optional_block_type END_STATEMENT'
    def __init__(self, p):
        p[0] = self
        self.type = p[3]
        self.lineno = p.lineno(1)
    def __repr__(self):
        return 'EndBlock(' + (self.type if self.type else 'any') + ')@' + str(self.lineno)

register(EndBlock, vars())

def p_optional_block_type(p):
    '''optional_block_type : TMPL
                           | VIEW
                           | SKIN
                           | ITEM
                           |'''
    if len(p) == 2:
        p[0] = p[1]
    else:
        p[0] = ''

class ViewDecl:
    'view_decl : begin_view_block template_seq end_block'
    def __init__(self, p):
        p[0] = self
        self.begin = p[1]
        self.seq = p[2]
        self.end = p[3]
    def __repr__(self):
        return 'ViewDecl(' + repr(self.begin) + ';' + repr(self.seq) + ';' + repr(self.end) + ')'
    def register(module):
        module['p_template_seq'] = lambda p: sequence(p)
        module['p_template_seq'].__doc__ = '''template_seq : template_seq template_decl
                                                           | template_decl
                                                           |'''

register(ViewDecl, vars())

class BeginViewBlock:
    '''begin_view_block : BEGIN_STATEMENT VIEW IDENTIFIER USES possibly_scoped_identifier END_STATEMENT
                        | BEGIN_STATEMENT VIEW IDENTIFIER USES possibly_scoped_identifier EXTENDS IDENTIFIER END_STATEMENT'''
    def __init__(self, p):
        p[0] = self
        self.identifier = p[3]
        self.contenttype = p[5]
        if len(p) == 7:
            self.extends = None
        else:
            self.extends = p[7]
        self.lineno = p.lineno(1)
    def __repr__(self):
        return 'BeginViewBlock("' + self.identifier + '";' + self.contenttype + (';' + self.extends if self.extends else '') + ')@' + str(self.lineno)

register(BeginViewBlock, vars())

def p_possibly_scoped_identifier(p):
    '''possibly_scoped_identifier : possibly_scoped_identifier SCOPE IDENTIFIER
                                  | IDENTIFIER'''
    if len(p) == 4:
        p[0] = p[1] + '::' + p[3]
    else:
        p[0] = p[1]

class TemplateDecl:
    '''template_decl : begin_template_block html_block end_block
                     | abstract_template_decl'''
    def __init__(self, p):
        p[0] = self
        if len(p) == 4:
            self.is_abstract = False
            self.begin = p[1]
            self.seq = p[2]
            self.end = p[3]
        else:
            self.is_abstract = True
            self.begin = p[1]
    def __repr__(self):
        r = 'TemplateDecl(' + repr(self.begin)
        if self.is_abstract:
            r += ';abstract)'
        else:
            r += ';' + repr(self.seq) + ';' + repr(self.end)
        r += ')'
        return r

register(TemplateDecl, vars())

class BeginTemplateBlock:
    '''begin_template_block : BEGIN_STATEMENT TMPL IDENTIFIER LPAREN expr_list RPAREN END_STATEMENT'''
    def __init__(self, p):
        p[0] = self
        self.identifier = p[3]
        self.params = p[5]
        self.lineno = p.lineno(1)
    def __repr__(self):
        return 'BeginTemplateBlock(' + self.identifier + '(' + ','.join(self.params) + '))@' + str(self.lineno)

register(BeginTemplateBlock, vars())

class AbstractTemplateDecl:
    '''abstract_template_decl : BEGIN_STATEMENT TMPL IDENTIFIER LPAREN expr_list RPAREN EQ ZERO END_STATEMENT'''
    def __init__(self, p):
        p[0] = self
        self.identifier = p[3]
        self.params = p[5]
        self.lineno = p.lineno(1)
    def __repr__(self):
        return 'AbstractTemplateDecl(' + self.identifier + '(' + ','.join(self.params) + '))@' + str(self.lineno)

register(AbstractTemplateDecl, vars())

def p_expr_list(p):
    '''expr_list : expr_list COMMA expr
                 | expr
                 |'''
    if len(p) == 4:
        p[0] = p[1] + [ p[3] ]
    elif len(p) == 2:
        p[0] = [ p[1] ]
    else:
        p[0] = []

p_html_block_sequence = lambda p: sequence(p)
p_html_block_sequence.__doc__ = '''html_block : html_block html_statement
                                              |'''

def p_html_statement_from_cpp_decl(p):
    'html_statement : cpp_decl'
    p[0] = p[1]

def p_html_statement_from_render_command(p):
    'html_statement : BEGIN_STATEMENT render_command END_STATEMENT'
    p[0] = p[2]

def p_html_statement_from_flow_control(p):
    '''html_statement : if_statement html_block end_block
                      | if_statement html_block else_statement html_block end_block
                      | foreach_statement html_block item_statement html_block end_block html_block end_block'''
    if len(p) == 4:
        p[0] = ( 'if', p[1], p[2], None )
    elif len(p) == 6:
        p[0] = ( 'if', p[1], p[2], p[4] )
    elif len(p) == 8:
        p[0] = ( 'foreach', p[1], p[2], p[4], p[6] )

def p_if_statement(p):
    '''if_statement : BEGIN_STATEMENT IF expr END_STATEMENT
                    | BEGIN_STATEMENT IF NOT expr END_STATEMENT'''
    if len(p) == 5:
        p[0] = ( p[3], False )
    else:
        p[0] = ( p[4], True ) # inverted

def p_else_statement(p):
    'else_statement : BEGIN_STATEMENT ELSE END_STATEMENT'
    pass

def p_foreach_statement(p):
    '''foreach_statement : BEGIN_STATEMENT FOREACH IDENTIFIER IN expr END_STATEMENT
                         | BEGIN_STATEMENT FOREACH ITEM IN expr END_STATEMENT'''
    p[0] = ( p[3], p[5] )

def p_item_statement(p):
    'item_statement : BEGIN_STATEMENT ITEM END_STATEMENT'
    pass

def p_render_command(p):
    '''render_command : EQ expr
                      | IF expr
                      | IF NOT expr
                      | URL STRING
                      | URL STRING USING expr_list'''
    if reserved[p[1]] == 'EQ':
        p[0] = ( 'output', p[2] )
    elif reserved[p[1]] == 'IF':
        if reserved[p[1]] == 'NOT':
            p[0] = ( 'if', '~(' + p[3] + ')' )
        else:
            p[0] = ( 'if', p[3] )
    elif reserved[p[1]] == 'URL':
        if len(p) == 5:
            p[0] = ( 'url', p[2], p[4] )
        else:
            p[0] = ( 'url', p[2], None )

def p_html_statement_from_HTML(p):
    '''html_statement : HTML
                      | NL'''
    p[0] = ( 'html', p[1] )

def p_expr(p):
    '''expr : IDENTIFIER
            | expr MEMBER expr
            | STAR expr
            | ITEM'''
    if len(p) == 2:
        p[0] = p[1]
    elif len(p) == 3:
        p[0] = p[1] + p[2]
    elif len(p) == 4:
        p[0] = p[1] + p[2] + p[3]

#lexer = lex.lex()
#parser = yacc.yacc()


input_data = """
<% c++ #include "content/bitgroup.h" %>
<% c++ #include "parent.tmpl.h" %>
<% skin canmap %>
	<% view bitgroup uses content::bitgroup extends parent %>

		<% template page_content() %>
<html>
    <head>
        <title>Stuff blah<%= title %></title>
        < TEST_ME %>
    </head>
</html>
		<% end template %>
	<% end view %>
<% end skin %>
"""

if False:
    import ply.lex as lex
    lexer = lex.lex()
    if True:
        lexer.input(input_data)

        while True:
            tok = lexer.token()
            if not tok:
                break
            print(tok)
    else:
        tree = yacc.parse(input_data, lexer=lexer)
        print(tree)
