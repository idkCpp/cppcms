#!/usr/bin/env python

import os
import re
import sys

#import ply.lex as lex
#import ply.yacc as yacc

states = [
	('statement', 'exclusive'),
    ('statementcommand', 'exclusive'),
    ('cppcommand', 'exclusive'),
	('block', 'exclusive')
	#('HTML', 'exclusive')
]

tokens = [
    'NL',
    'COMMAND',
    'BEGIN_STATEMENT','END_STATEMENT',
    'NUMBER','IDENTIFIER','STRING','CHAR','ZERO',
    'SCOPE', 'MEMBER', 'PTRMEMBER', 'LPAREN', 'RPAREN', 'COMMA', 'INC', 'DEC', 'STAR',
    'HTML'
    ]

reserved = {
        '=' : 'EQ',
        'skin' : 'SKIN',
        'view' : 'VIEW',
        'uses' : 'USES',
        'template' : 'TMPL',
        'extends' : 'EXTENDS',
        'url' : 'URL',
        'using' : 'USING',
        'if' : 'IF',
        'not' : 'NOT',
        'else' : 'ELSE',
        'foreach' : 'FOREACH',
        'in' : 'IN',
        'item' : 'ITEM',
        'end' : 'END',
        'c++' : 'CPP',
        }

tokens += reserved.values()

t_ignore = " \t"
t_statementcommand_ignore = " \t"
t_statement_ignore = " \t"
t_block_ignore = ""
t_cppcommand_ignore = ""

def t_begin_statement(t):
    r'<%'
    t.lexer.push_state('statement')
    t.lexer.push_state('statementcommand')
    t.type = 'BEGIN_STATEMENT'
    return t

def t_statementcommand_COMMAND(t):
    r'[^ \t\n]+'

    if t.value not in reserved:
        raise Exception(t.value + " is not a valid command")

    t.type = reserved[t.value]
    t.lexer.pop_state()
    t.lexer.command = t.type
    if t.type == 'CPP':
        t.lexer.pop_state()
        t.lexer.push_state('cppcommand')
    return t

t_cppcommand_COMMAND = r'.+(?=%>)'

def t_statement_end(t):
    r'%>'
    t.lexer.pop_state()
    if t.lexer.command in [ 'TMPL', 'IF', 'FOREACH', 'ITEM' ]:
        t.lexer.push_state('block')
    elif t.lexer.command == 'END':
        if t.lexer.lexstate == 'block':
            t.lexer.pop_state()
    t.type = 'END_STATEMENT'
    return t

t_cppcommand_end = t_statement_end


t_statement_INC = r'\+\+'
t_statement_SCOPE = r'::'
t_statement_MEMBER = r'\.'
t_statement_PTRMEMBER = r'->'
t_statement_LPAREN = r'\('
t_statement_RPAREN = r'\)'
t_statement_COMMA = r','
t_statement_STRING = r'"([^"]|\\")*"'
t_statement_CHAR = r'\'.\''
t_statement_STAR = r'\*'

t_block_HTML = r'([^<]|<(?!%))+'

t_block_begin_statement = t_begin_statement

def t_statement_IDENTIFIER(t):
    r'[a-zA-Z]\w*'
    t.type = reserved.get(t.value, 'IDENTIFIER')
    return t


def t_error(t):
    print('error: ' + str(t))
    return t

t_statement_error = t_error
t_statementcommand_error = t_error
t_cppcommand_error = t_error
t_block_error = t_error

def t_NL(t):
    r'\n+'
    t.lexer.lineno += len(t.value)

t_statement_NL = t_NL
t_statementcommand_NL = t_NL
t_cppcommand_NL = t_NL

def t_block_NL(t):
    r'\n+'
    t.lexer.lineno += 1
    return t

start = 'translation_unit'

from cppcms_tmpl.common import sequence, non_empty_sequence

from cppcms_tmpl import register

from cppcms_tmpl.core import CppDecl, EndBlock, p_translation_unit, p_decl, p_optional_block_type
register(CppDecl, vars())
register(EndBlock, vars())

from cppcms_tmpl.cpp import p_possibly_scoped_identifier, p_expr_list, p_expr

from cppcms_tmpl.skin import SkinDecl, BeginSkinBlock
register(SkinDecl, vars())
register(BeginSkinBlock, vars())


from cppcms_tmpl.view import ViewDecl, BeginViewBlock
register(ViewDecl, vars())
register(BeginViewBlock, vars())

from cppcms_tmpl.template import TemplateDecl, BeginTemplateBlock, AbstractTemplateDecl
register(TemplateDecl, vars())
register(BeginTemplateBlock, vars())
register(AbstractTemplateDecl, vars())


from cppcms_tmpl.html import IfBlock, IfElseBlock, IfStatement, ElseStatement, ForeachBlock, ForeachStatement, Html, OutputStatement, UrlStatement, p_html_block_sequence, p_html_statement_from_cpp_decl
register(IfBlock, vars())
register(IfElseBlock, vars())
register(IfStatement, vars())
register(ElseStatement, vars())
register(ForeachBlock, vars())
register(ForeachStatement, vars())
register(Html, vars())
register(OutputStatement, vars())
register(UrlStatement, vars())

#lexer = lex.lex()
#parser = yacc.yacc()


input_data = """
<% c++ #include "content/bitgroup.h" %>
<% c++ #include "parent.tmpl.h" %>
<% skin canmap %>
	<% view bitgroup uses content::bitgroup extends parent %>

		<% template page_content() %>
<html>
    <head>
        <title>Stuff blah<%= title %></title>
        < TEST_ME %>
    </head>
</html>
		<% end template %>
	<% end view %>
<% end skin %>
"""

if False:
    import ply.lex as lex
    lexer = lex.lex()
    if True:
        lexer.input(input_data)

        while True:
            tok = lexer.token()
            if not tok:
                break
            print(tok)
    else:
        tree = yacc.parse(input_data, lexer=lexer)
        print(tree)
